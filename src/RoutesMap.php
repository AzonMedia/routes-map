<?php

declare(strict_types=1);

namespace Azonmedia\RoutesMap;

use Azonmedia\Exceptions\InvalidArgumentException;
use Azonmedia\Routing\Interfaces\RouterInterface;
use Azonmedia\Utilities\AlphaNumUtil;
use Azonmedia\Utilities\FilesUtil;
use Azonmedia\Translator\Translator as t;

/**
 * Class RoutesMap
 * @package Azonmedia\RoutesMap
 *
 * Generates a map of class:method => route like:
 * { "class:method":"/some/route", "class2:method2":"/another/route" }
 * The HTTP method is ignored
 *
 * This map is used to obtain the routes for the classes and to allow for the routes to be changed.
 * A change in the route will trigger a change in the javacsript routes too.
 */
class RoutesMap
{

    /**
     * @var RouterInterface
     */
    protected RouterInterface $Router;

    /**
     * @var string
     */
    protected string $routes_map_file;

    /**
     * @var bool 
     */
    protected bool $routes_map_dumped_flag = false;

    /**
     * RoutesMap constructor.
     * @param RouterInterface $Router
     * @param string $routes_map_file Where the javascript routes map should be dumped.
     * @throws InvalidArgumentException
     */
    public function __construct(RouterInterface $Router, string $routes_map_file)
    {
        $routes_map_dir = dirname($routes_map_file);
        $file_error = FilesUtil::file_error($routes_map_dir, $is_writable = true, $is_dir = true, $arg_name = t::_('routes map directory') );
        if ($file_error) {
            throw new InvalidArgumentException($file_error);
        }
        $this->Router = $Router;
        $this->routes_map_file = $routes_map_file;
    }

    /**
     * @return string
     */
    public function get_routes_map_file(): string
    {
        return $this->routes_map_file;
    }

    /**
     * Writes the routes map to the self::get_routes_map_file() file.
     */
    public function dump_routes_map(): void
    {
        $this->set_routes_map_dumped(true);
        $routes_map_str = $this->as_string();
        file_put_contents($this->get_routes_map_file(), $routes_map_str);//replace the old file
    }

    /**
     * Marks that the routes map was dumped.
     * @param bool $flag
     */
    public function set_routes_map_dumped(bool $flag): void
    {
        $this->routes_map_dumped_flag = $flag;
    }

    /**
     * Returns bool is the routes map dumped already to the specified file.
     * @return bool
     */
    public function is_routes_map_dumped(): bool
    {
        return $this->routes_map_dumped_flag;
    }

    /**
     * @return string
     */
    public function __toString()
    {
        return $this->as_string();
    }

    /**
     * Returns the routes map as javascript object.
     * @return string
     */
    public function as_string(): string
    {
        return $this->generate_routes_map();
    }

    /**
     * Generates the javascript from the routes & meta data
     * @return string
     */
    protected function generate_routes_map(): string
    {
        $ret = '/** File generated by Azonmedia\RoutesMap (azonmedia\routes-map) */'.PHP_EOL;
        $ret .= '/* eslint no-dupe-keys: 0 */'.PHP_EOL;
        $ret .= '/* eslint max-len: 0 */'.PHP_EOL;
        $ret .= 'export default {'.PHP_EOL;
        $routes = $this->Router->get_all_routes();
        $meta = $this->Router->get_all_meta_data();
        foreach ($routes as $route => $route_data) {
            foreach ($route_data as $methods => $controller) {
                $class = $controller[0];
                $class_method = $controller[1];
                if (isset($meta[$route][$methods]['class']) && $meta[$route][$methods]['class'] !== $controller[0]) {
                    //the meta takes precedence as there may be multiple routes matching the same class
                    $class = $meta[$route][$methods]['class'];
                }
                //if there duplicate routes it is nota problem - the last one overrides the previous
                //$ret .= AlphaNumUtil::indent(sprintf('"%s:%s" : "%s",', $controller[0], $controller[1], $route) ).PHP_EOL;
                $ret .= AlphaNumUtil::indent(sprintf('"%s:%s" : "%s",', addslashes($class), $class_method, $route) ).PHP_EOL;
            }
        }
        $ret .= '}'.PHP_EOL;
        return $ret;
    }
}